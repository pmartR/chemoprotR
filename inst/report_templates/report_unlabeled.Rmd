---
title: "Unlabeled HTP Chemoproteomics Report"
author: "Damon Leach, Kelly Stratton, Lisa Bramer"
date: "`r Sys.Date()`"
output: html_document
bibliography: analysis_ref.bib
---

```{r, echo = FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F,fig.width = 10)

knitr::knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark = ",")
})

# load in necessary libraries
library(pmartR)
library(chemoprotR)
library(here)
```

## Software Used

R 4.2.1 [@R] was used for all computations. The following packages were used:

| Package         | Use                                           | Reference    |
|-----------------|-----------------------------------------------|--------------|
| dplyr           | General data processing                       | @dplyr       |
| ggplot2         | Creating figures                              | @ggplot      |
| pmartR          | Processing/normalizing/analyzing protein data | @pmartr2      |

```{r}
here::i_am("Code/Report_unlabeled.Rmd")

# load in the data
lab_info <- readRDS(here("Data","unlabeled_information.RDS"))
# pull out the pmart object
htp_pmart <- lab_info$pmartObj
# pull out the msgf value
msgf <- lab_info$msgf
# find the fdata colum information
fdat <- lab_info$fdata_info
# find mage information
mage <- lab_info$mage_info
# find norm information
norm_inf <- lab_info$norm_info
# add in rollup information
roll_info <- lab_info$rollup_info
# add in protein data
prot_collect <- lab_info$protein_info
# find name of data sheet
data_name <- lab_info$data_name
# find outlier names
outlier_names <- lab_info$outlier_info

# grouping name
grouping_name <- lab_info$fdata_info$group_name
```

The dataset contains `r length(unique(htp_pmart$e_meta[[mage$peptide_name]]))` unique peptides mapping to `r length(unique(htp_pmart$e_meta[[mage$protein_name]]))` unique proteins. There are `r attr(htp_pmart,"data_info")$num_miss_obs` missing observations (`r round(attr(htp_pmart,"data_info")$prop_missing *100,2)`%).

## Filters

```{r}
# obtain pmart object cnames
edat_cname = get_edata_cname(htp_pmart)

# within that job remove the molecules that are not below a certain msgf threshold
emetaJobMSGF <- htp_pmart$e_meta[htp_pmart$e_meta[[mage$msgf_specprob_name]] <= msgf,]
keepPep <- emetaJobMSGF[[edat_cname]]
cfilt <- custom_filter(htp_pmart,e_data_keep = keepPep)
htp_msgf <- applyFilt(cfilt,htp_pmart)

# sum up redundancy
htp_no_redundancy <- chemoprotR::redundancy_sum(pmartObj = htp_msgf, mage_names = mage, protein_collect_names = prot_collect, labeled = FALSE)

# run group designation on the data
htp_no_redundancy <- group_designation(htp_no_redundancy,main_effects = fdat$group_name)
```

Data were filtered such that only peptides with a MSGF spectral probability value less than `r msgf` were retained. After removing peptides with MSGF spectral probability values exceeding this threshold, `r nrow(htp_msgf$e_data)` peptides remained in the data. Peptide redundancies were summed such that each row corresponded to a unique peptide.

**Figure 1** shows the number of missing values per sample colored by grouping. After summing up peptide redundancies, there are `r attr(htp_no_redundancy,"data_info")$num_miss_obs` missing observations (`r round(attr(htp_no_redundancy,"data_info")$prop_missing *100,2)`%).

```{r}
# find missing values
missObj = pmartR::missingval_result(htp_no_redundancy)
plot(missObj,htp_no_redundancy,color_by = grouping_name)
```

**Figure 1: Barplot of missing values for each sample colored by Group**

## Potential Outliers

```{r rmd_filter positive}
# log transform the data
htp_log <- edata_transform(htp_no_redundancy,"log2")

htp_log <- group_designation(htp_log,main_effects = fdat$group_name)

# if statement for when we have too few groups
rmd_res = rmd_filter(htp_log, metrics = c("Correlation","Skewness","MAD"),ignore_singleton_groups = FALSE)
out_id = summary(rmd_res, pvalue_threshold = 0.0001)$filt

# obtain pmart object cnames
edat_cname = get_edata_cname(htp_log)
fdat_cname = get_fdata_cname(htp_log)
emet_cname = get_emeta_cname(htp_log)
```

We ran a robust Mahalanobis distance to look for potential outliers [@rmd]. We used the metrics of correlation to other samples in the same protocol, skewness, and MAD of the molecule abundance profile. The null hypothesis is that a sample is not an outlier. We used a threshold of a p-value less than 0.0001. **`r if("NULL" %in% out_id){"Figure 2"} else{"Figure 2a"}`** shows the log2 distance score, where points falling above the line correspond to samples with a p-value < 0.0001.

```{r}
knitr::knit_hooks$set(inline = function(x) {
  prettyNum(x)
})
```

`r if(!"NULL" %in% out_id){"We then looked at the potential outliers and holistically decided whether removal was warranted. **Figure 2b** shows the values for each of the 4 different metrics used to calculate the robust Mahalanobis distance for potential outliers."}` `r if(!"NULL" %in% out_id & length(outlier_names) == 0){"After some careful consideration, it was determined that all samples should remain in the data."}` `r if(!"NULL" %in% out_id & length(outlier_names) == 1){"After some careful consideration, it was determined the following sample should be removed from the data: "}` `r if(!"NULL" %in% out_id & length(outlier_names) == 1){paste0(outlier_names,".")}` `r if(!"NULL" %in% out_id & length(outlier_names) > 1){"After some careful consideration, it was determined the following samples should be removed from the data: "}` `r if(!"NULL" %in% out_id & length(outlier_names) > 1){paste0(paste(outlier_names, collapse = ", "),".")}`

```{r}
knitr::knit_hooks$set(inline = function(x) {
  prettyNum(x, big.mark = ",")
})
```

```{r}
# plot the full plot
plot(rmd_res, pvalue_threshold = 0.0001)
```

**`r if("NULL" %in% out_id){"Figure 2: Sample Outliers Results"}`**

**`r if(!"NULL" %in% out_id){"Figure 2a: Sample Outliers Results"}`**

```{r}
# plot specific outliers
if(!"NULL" %in% out_id){
  plot(rmd_res,sampleID = out_id)
}
```

**`r if(!"NULL" %in% out_id){"Figure 2b: RMD Distance values for potential outliers"}`**

```{r}
# remove the specified outliers
if(length(outlier_names) > 0){
  cfilt <- custom_filter(htp_log,f_data_remove = outlier_names)
  htp_log <- applyFilt(cfilt,htp_log)
}
```

## Normalization

```{r, out.width = "50%"}
# now we can normalize the data
htp_normalized <- htp_normalize(pmartObj = htp_log, norm_function = norm_inf$norm_fn, backtransform_val = norm_inf$backtransform)
```

Data were normalized using `r norm_inf$norm_fn` centering. `r if(norm_inf$backtransform){"A group specific backtransform was applied to the data"}` `r if(!norm_inf$backtransform){"A group specific backtransform was not applied to the data"}`. **Figure 2** shows the data before (left) and after (right) normalization.

```{r, out.width = "50%"}
# plot the data
plot(htp_log,color_by = grouping_name)
plot(htp_normalized, color_by = grouping_name)
```

**Figure 2: Peptide-level data before (left) and after (right) undergoing normalization**

## Protein Quantitation

```{r}
if(roll_info$rollup_method %in% c("rollup","rrollup")){
  htp_protein <- protein_quant(htp_normalized,method = roll_info$rollup_method,
                               combine_fn = roll_info$centering_fn)
} else {
  htp_protein <- sum_pep_quant(htp_normalized,top3 = F)
}
```

Protein quantitation was performed using the `r roll_info$rollup_method` method, resulting in a dataset with `r nrow(htp_protein$e_data)` unique proteins and `r attr(htp_protein,"data_info")$num_miss_obs` missing observations (`r round(attr(htp_protein,"data_info")$prop_missing*100,2)`%).

## Reverse Hits/Contaminants

```{r}
# create custom filter to remove the contaminant proteins
contamProtein <- htp_protein$e_meta[[mage$protein_name]][grep("Contam",htp_protein$e_meta[[mage$protein_name]])]
cfilterContam <- custom_filter(omicsData = htp_protein, e_meta_remove = contamProtein)
htp_protein <- applyFilt(cfilterContam,htp_protein)

xxxProtein <- htp_protein$e_meta[[mage$protein_name]][grep("XXX",htp_protein$e_meta[[mage$protein_name]])]
cfilterxxx <- custom_filter(omicsData = htp_protein, e_meta_remove = xxxProtein)
htp_protein <- applyFilt(cfilterxxx,htp_protein)
```

Reverse hits and contaminants were then removed resulting in a dataset with `r nrow(htp_protein$e_data)` unique proteins and `r attr(htp_protein,"data_info")$num_miss_obs` missing observations (`r round(attr(htp_protein,"data_info")$prop_missing*100,2)`%). **Figure 3** shows the resulting normalized protein-level data.

```{r}
plot(htp_protein, color_by = grouping_name)
```

**Figure 3: Protein-level data after undergoing quantitation and removal of reverse hits and contaminants**

## Statistical Results

Analysis of variance (ANOVA) was used to compare each pair of sample groups when sufficient observations (at least 2 in each group being compared) were present for this test. **Figure 4** shows the number of significant differences (unadjusted p-value < 0.05) between each pair of groups, along with a volcano plot.

```{r}
# need to run imdanova filter
# imdFilt <- imdanova_filter(htp_protein)
# htp_protein <- applyFilt(imdFilt,htp_protein,min_nonmiss_anova = 2)

# in fdata spreadsheet, add a column that specifies comparisons to parse (and also direction)
statResObj <- imd_anova(htp_protein, test_method = "combined", equal_var = FALSE)

# add back in emeta information for results
# load emeta data
add_on_emeta <- htp_normalized$e_meta[,c(which(colnames(htp_normalized$e_meta) == mage$protein_name),
                                         which(colnames(htp_normalized$e_meta) %in% prot_collect))] %>%
  dplyr::distinct()
```

```{r}
# this code updates the statRes object created in pmartR
# such that if a value contains only 1 lipid
# the associated p-value and fold change become NA
# and the flag becomes 0
num_count_var = which(stringr::str_detect(colnames(statResObj),"Count_"))
for(i in 1:nrow(statResObj)){
  for(j in 1:length(num_count_var)){
      if(statResObj[i,num_count_var[j]] == 1){
        # find the name of the samples that are bad
        bad_sample = stringr::str_remove(colnames(statResObj)[num_count_var[j]],"Count_")

        # fold change becomes NaN
        statResObj[i,stringr::str_detect(colnames(statResObj),"Fold_change") & stringr::str_detect(colnames(statResObj),bad_sample)] <- NaN
        # pvalue becomes NaN
        statResObj[i,stringr::str_detect(colnames(statResObj),"P_value_A") & stringr::str_detect(colnames(statResObj),bad_sample)] <- NaN
        # flag becomes NaN
        statResObj[i,stringr::str_detect(colnames(statResObj),"Flag_A") & stringr::str_detect(colnames(statResObj),bad_sample)] <- 0
      }
  }
}

# this portion of the code then updates
# the attribute "number_significant"
# for the statResObj object to assist with
# the plotting commands of statResObj objects
anova_flags <- statResObj[, grepl("^Flag_A", names(statResObj))] %>%
  data.matrix()
imd_flags <- statResObj[, grepl("^Flag_G", names(statResObj))] %>%
    data.matrix()
up_a <- apply(anova_flags, 2, function(x){length(which(x == 1))})
down_a <- apply(anova_flags, 2, function(x){length(which(x == -1))})
  comparisons <- attr(statResObj, "comparisons")
up_g <- apply(imd_flags, 2, function(x){length(which(x == 1))})
down_g <- apply(imd_flags, 2, function(x){length(which(x == -1))})

attr(statResObj,"number_significant") <- data.frame(
    Comparison = comparisons,
    Up_total = up_a + up_g,
    Down_total = down_a + down_g,
    Up_anova = up_a,
    Down_anova = down_a,
    Up_gtest = up_g,
    Down_gtest = down_g,
    row.names = NULL
)
```

```{r,out.width = "50%"}
plot(statResObj)
plot(statResObj,plot_type = "volcano")
```

**Figure 4: Number of proteins that had significant differences between groups (left) and the corresponding volcano plot (right)**

```{r}
# add in protein collection information
emeta_info <- htp_protein$e_meta %>%
  dplyr::select(mage$protein_name,n_peps_used)

statRes_df <- statResObj %>%
  data.frame() %>%
  dplyr::left_join(add_on_emeta, by = mage$protein_name) %>%
  dplyr::left_join(emeta_info, by = mage$protein_name) %>%
  dplyr::rename(Number_Peptides_Used = n_peps_used)
# change NaN to NA for excel purpose
statRes_df[sapply(statRes_df, is.nan)] <- "NA"
# add back in NA values as string for writexl purposes
htp_protein$e_data[is.na(htp_protein$e_data)] <- "NA"

# save the results
# remove the xlsx from name if there
data_name = stringr::str_remove(data_name,".xlsx")
list_of_datasets <- list("results" = statRes_df,
                         # we also want log2 normalized data
                         "log2_normalized" = htp_protein$e_data)
writexl::write_xlsx(list_of_datasets, 
           path = here("Results",paste0("results_",data_name,".xlsx")))
knitr::knit_hooks$restore()
```

Statistical results are provided in the file "`r paste0("results_",as.character(data_name),".xlsx")`". This file contains the two sheets. The first sheet contains the statistical results with following columns:

| Column Name             | Description                                |
|-------------------------|--------------------------------------------|
| Protein                 | Protein identifier                         |
| Count\_X                | Number of counts for Group X               |
| Mean\_X                 | Mean value for Group X                     |
| Fold\_change\_X\_vs\_Y  | log2 fold-change of comparison X/Y         |
| P\_value\_A\_X\_vs\_Y   | Adjusted p-value for anova comparison of X and Y |
| P\_value\_G\_X\_vs\_Y   | Adjusted p-value for g-test comparison of X and Y |
| Flag\_A\_X\_vs\_Y       | Flag for anova comparison of X and Y condition   |
| Flag\_G\_X\_vs\_Y       | Flag for g-test comparison of X and Y condition   |
| Protein\_Collection\_ID | Protein collection ID                      |
| Protein\_Collection     | Protein collection                         |
| Description             | Description                                |
| Reference\_ID           | Reference ID                               |
| Residue\_Count          | Residue count                              |
| Monotopic\_Mass         | Monotopic mass                             |
| Protein\_ID             | Protein ID                                 |
| Number_Peptides_Used    | Number of peptides used for protein rollup |

The second sheet contains the log2 normalized values at the protein level.

## References